# performance analysis

Существует множества методологий анализа производительности такие как: чек-лист инструментов, метод USE, определение характеристик рабочей нагрузки, анализ задержки и многие другие.  
Рассмотрим один из них. Метод USE (Utilization, Saturation, and Errors — потребление, насыщение и ошибки) используют на ранних этапах исследования производительности для выявления узких мест и ошибок во всех компонентах, прежде чем переходить к более глубоким и трудоемким стратегиям.
Термины в этом определении интерпретируются так:
- Ресурсы: все функциональные компоненты сервера подлежащие анализу (процессоры, память, диск и т.д.).
- Потребление: процент времени для заданного временного интервала, в течение которого ресурс обслуживал рабочую нагрузку. 
- Насыщение: такое состояние ресурса, когда для него есть дополнительная работа, но он не может приступить к ее выполнению немедленно, из-за чего задания часто вынуждены ждать в очереди.
- Ошибки: наличие или рост количества ошибок.

## ТИПЫ ИНСТРУМЕНТОВ
Инструменты наблюдения тоже удобно классифицировать по области покрытия — система целиком (system-wide) или отдельный процесс (per-process), а также по тому, на чем они основаны — на счетчиках или событиях.
Некоторые инструменты присутствуют в нескольких классах. Например, top, помимо активных процессов, выводит информацию о системе в целом.
К инструментам, основанным на событиях, относятся профилировщики и трассировщики. Профилировщики наблюдают за активностью, выполняя серию моментальных снимков по событиям и создавая грубую картину цели. Трассировщики отслеживают каждое интересующее событие и могут обрабатывать их, что можно использовать, например, для создания нестандартных счетчиков.

### Традиционные инструменты получения статистик.
По умолчанию в дистрибутиве Linux устанавлены пакеты procps (ps, vmstat, uptime, top) и util-linux (dmesg, lsblk, lscpu), плюс дополнительные пакеты такие как sysstat (iostat, mpstat, pidstat, sar), iproute2 (ip, ss, nstat, tc), net-tools (arp, ifconfig, netstat). Все эти инструменты можно отнести к традионным инструментам получения статистик.

Наверное одно из первых действий, которое выполняется на сервере при анализе производительности и траблшутинге, это проверка логов. Их можно найти по пути /var/log/syslog (для AstraLinux) и /var/log/messages (для RH). Это текстовые файлы которые можно просматиривать любым текстовым редактором или утилитой `cat`, например отфильтровав полученный вывод утилитой `grep` по заданному регулярному выражению, например так:
```bash
cat /var/log/messages | grep -Ei "error|fail|warning"
```
Также посмотреть сообщения ядра, включая события OOM (нехватки памяти) можно инструментом `dmesg` или средством для работы с журналами `journalctl`:
```bash
dmesg -T | tail
journalctl -k | tail
# или отфильтровать по приоритету сообщения
dmesg -Tl err,warn
journalctl -k -p err..warning
```

#### Инструменты наблюдения за производительностью процессора
Наверное первое что смотрят анализируя производительность сервера это средние значения нагрузки
uptime - одна из нескольких команд, позволяющих получить эту метрику
```bash
$ uptime
9:04pm up 268 day(s), 10:16, 2 users, load average: 7.76, 8.32, 8.60
```
Последние три числа — это средние значения нагрузки за последние 1, 5 и 15 минут. В Linux средние значения нагрузки отражают потребность в ресурсах системы, таких как процессоры и диски. 
Чтобы понять какое нормальное значение LA нужно знать количество ядер в системе (получить можно командами nproc, lscpu, cat /proc/cpuinfo|grep processor). В Unix системах подразумевается что нормальное значение LA это меньше либо равно колличеству ядер в системе, но в Linux в расчет LA попадают процессы не только в статусе R (ожидающих в очереди на выполнение и выполняемых на процессоре) но и в статусе D (ожидающих данных с системы ввода/вывода). Поэтому если LA большой то это может говорить о проблеммах с системой ввода/вывода.
Рассмотрим ОС с 64 процессорами и средней нагрузкой 128. Если бы нагрузка была только нагрузкой на процессор, это значило бы, что в среднем на каждом процессоре всегда выполняется один поток и есть по одному потоку в очереди на выполнение для каждого процессора. Для той же системы средняя нагрузка 20 будет указывать на значительный запас, потому что эта система способна запустить еще 44 потока до того, как все процессоры окажутся заняты.
6.6.1

vmstat 1 - команда получения статистик использования виртуальной памяти выводит, средние значения нагрузки на процессор для всей системы и количество выполняемых потоков
```bash
$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r b  swpd free buff cache si so bi bo in cs us sy id wa st
15 0 0 451732 70588 866628 0 0 1 10 43 38 2 1 97 0 0
15 0 0 450968 70588 866628 0 0 0 612 1064 2969 72 28 0 0 0
15 0 0 450660 70588 866632 0 0 0 0 961 2932 72 28 0 0 0
15 0 0 450952 70588 866632 0 0 0 0 1015 3238 74 26 0 0 0
```
- r: длина очереди на выполнение — общее количество потоков, готовых к выполнению.
- b: Количество процессов в непрерывном сне uninterruptible sleep, ожидает дискового ввода/вывода (показывается некоторыми инструментами как состояние «D»).
- swpd: объем выгружаемой памяти в килобайтах;
- free: свободная доступная память в килобайтах;
- buff: память в кэше буферов в килобайтах;
- cache: память в кэше страниц в килобайтах;
- si: объем памяти, загруженной с устройства подкачки в килобайтах;
- so: объем памяти, выгруженной на устройство подкачки в килобайтах
- bi: блоки, полученные с блочного устройства (blocks/s);
- bo: блоки, отправленные на блочное устройство (blocks/s)
- us: процент времени выполнения в режиме пользователя.
- sy: процент времени выполнения в режиме системы (ядра).
- id: процент времени бездействия.
- wa: процент времени, проведенного потоками в ожидании завершения ввода/вывода, когда потоки оставались заблокированными на время дискового ввода/вывода.
- st: процент заимствованного времени — время, потраченное на обслуживание других клиентов в виртуализированных средах.
В первой строке должна выводиться обобщенная информация с момента загрузки. Но в Linux вывод в столбцах procs и memory начинается со значений, характеризующих текущее состояние. В Linux столбец r — это общее количество задач, ожидающих выполнения плюс выполняющихся. Если в столбцах si и so постоянно выводятся значения, отличные от нуля, это означает, что система испытывает нехватку памяти и выполняет подкачку с устройства или файла подкачки.
7.5.1

Вот пример вывода статистики по процессорам, утилитой mpstat:
```bash
$ mpstat -P ALL 1
Linux 5.3.0-1009-aws (ip-10-0-239-218) 02/01/20 _x86_64_ (2 CPU)
18:00:32 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle
18:00:33 all 32.16 0.00 61.81 0.00 0.00 0.00 0.00 0.00 0.00 6.03
18:00:33 0 32.00 0.00 64.00 0.00 0.00 0.00 0.00 0.00 0.00 4.00
18:00:33 1 32.32 0.00 59.60 0.00 0.00 0.00 0.00 0.00 0.00 8.08
```
- CPU: логический идентификатор процессора или all — в строке со сводной информацией.
- %usr: время работы в режиме пользователя, исключая %nice.
- %nice: время работы в режиме пользователя для процессов с пониженным приоритетом.
- %sys: время работы в режиме системы (ядра).
- %iowait: процент времени, проведенного потоками в ожидании завершения ввода/вывода, когда потоки оставались заблокированными на время дискового ввода/вывода.
- %irq: потребление процессора аппаратными прерываниями.
- %soft: потребление процессора программными прерываниями.
- %steal: время, потраченное на обслуживание других пользователей.
- %guest: время, потраченное в гостевых виртуальных машинах.
- %gnice: время для выполнения гостя с пониженным приоритетом.
- %idle: время бездействия.
Ключевые столбцы: %usr, %sys, %iowait и %idle, они определяют потребление процессоров и показывают соотношение времени в режиме пользователя/ядра. Также увеличенная нагрузка на один из процессоров может указывать на плохое масштабирование потоков выполнения.
6.6.3


#### Инструменты наблюдения за работой дисков.
iostat - выводит сводную статистику ввода/вывода для каждого диска, сообщая метрики, характеризующие рабочую нагрузку, потребление и насыщение.
Название «iostat» — это сокращение от «I/O statistics» (статистики ввода/вывода), показывает дисковый ввод ввод/вывод, а не ввод/вывод в файловую систему. Команде iostat можно передавать различные параметры, за которыми следуют необязательные значения интервала и счетчик.
Вот некоторые наиболее часто используемые параметры:
- c: выводит отчет о потреблении процессора;
- d: выводит отчет о потреблении дисков;
- k: выводит объемы в килобайтах вместо блоков (по 512 байт);
- m: выводит объемы в мегабайтах вместо блоков (по 512 байт);
- p: добавляет статистики по разделам;
- t: выводит отметки времени;
- x: выводит расширенные статистики;
- s: режим узкого вывода;
- z: пропускает вывод информации об устройствах с нулевой активностью.
Чаще используют расширенный режим, который выводит дополнительные столбцы: метрики IOPS и пропускной способности для определения характеристик рабочей нагрузки, потребление дисков и размеры очередей для метода USE, а также время отклика диска для определения характеристик производительности и анализа задержек.
Со временем в расширенный вывод добавлялось все больше полей, и в последней версии вывод был шириной 197 символов. Он не умещается по ширине во многих терминалах, что затрудняет чтение вывода из-за переноса строк. В 2017 году было добавлено решение, параметр -s, обеспечивающий «узкий» вывод и предназначенный для отображения в терминалах с шириной строк в 80 символов.
Вот пример узкого (-s) расширенного (-x) вывода статистик с пропуском устройств с нулевой активностью (-z):
```bash
$ iostat -sxz 1
avg-cpu: %user %nice %system %iowait %steal %idle
15.82 0.00 10.71 31.63 1.53 40.31
Device      tps    kB/s    rqm/s    await     aqu-sz    areq-sz     %util
nvme0n1 1642.00 9064.00   664.00     0.44       0.00       5.52    100.00
```
Значение столбцов:
- tps: количество транзакций в секунду (IOPS);
- kB/s: килобайт в секунду;
- rqm/s: количество запросов в секунду, добавленных в очередь и объединенных;
- await: среднее время отклика ввода/вывода, включая время ожидания в очереди драйвера и время отклика устройства ввода/вывода (в миллисекундах);
- areq-sz: средний размер запроса в килобайтах;
- aqu-sz: среднее количество запросов, ожидающих в очереди запросов драйвера и обрабатываемых устройством;
- %util: процент времени, в течение которого устройство было занято обработкой запросов ввода/вывода (потребление).
Наиболее важная метрика производительности — это await, показывающая общее среднее время ожидания ввода/вывода. Это время может увеличиваться по разным причинам: из-за ожидания в очередях (из-за высокой нагрузки), больших размеров ввода/вывода, произвольного ввода/вывода на вращающихся дисках и ошибок устройств.
Метрика %util это всего лишь оценка потребления, доля времени, в течение которого устройство было занято обработкой запросов и она может почти ничего не значить для виртуальных устройств, охватывающих несколько дисков.
Ненулевые значения в столбце rqm/s показывают, что последовательные запросы объединялись перед отправкой на устройство для повышения производительности. Этот показатель также является признаком последовательной нагрузки. Поскольку величина areq-sz измеряется после слияния запросов, небольшие значения (8 Кбайт или меньше) могут служить признаком рабочей нагрузки произвольного ввода/вывода, запросы которой не удалось объединить. Большие размеры могут соответствовать либо большим операциям ввода/вывода, либо объединенным запросам рабочей нагрузки последовательного ввода/вывода (как в примере выше).

Без параметра -s команда iostat с параметром -x выводит намного больше
столбцов.
```bash
$ iostat -x 1
Device r/s rkB/s rrqm/s %rrqm r_await rareq-sz w/s wkB/s
wrqm/s %wrqm w_await wareq-sz d/s dkB/s drqm/s %drqm d_await dareq-sz
f/s f_await aqu-sz %util
nvme0n1 0.23 9.91 0.16 40.70 0.56 43.01 3.10 33.09
0.92 22.91 0.89 10.66 0.00 0.00 0.00 0.00 0.00 0.00
0.00 0.00 0.00 0.12
```
Многие метрики, доступные с параметрами -sx, разбиты на компоненты, соответствующие операциям чтения, записи, синхронизации (flush) и усечения (discard).
Вот краткое описание дополнительных столбцов:
- r/s, w/s, d/s, f/s: запросов на чтение, запись, усечение и синхронизацию, выполняемых дисковым устройством в секунду (после слияния);
- rkB/s, wkB/s, dkB/s: объем чтения, записи и усечения в килобайтах в секунду;
- %rrqm/s, %wrqm/s, %drqm/s: количество запросов в секунду на чтение, запись и усечение, добавленных в очередь и объединенных, в процентах от общего количества запросов каждого типа;
- r_await, w_await, d_await, f_await: среднее время отклика для чтения, записи, усечения и синхронизации, включая время ожидания в очереди драйвера и время отклика устройства (миллисекунд);
- rereq-sz, wareq-sz, dareq-sz: средний размер чтения, записи и усечения (килобайт).
Возможность исследовать операции чтения и записи по отдельности очень важна. Приложения и файловые системы обычно используют приемы уменьшения задержки записи (например, кэширование с отложенной записью) (столбец rqm/s) и тем самым уменьшают вероятность блокировки приложения на время выполнения записи на диск.
Поддержка вывода статистик отмены и синхронизации появилась в iostat недавно. Операции усечения (discard) освобождают блоки на диске (команда ATA TRIM), а соответствующая статистика была добавлена в ядро Linux 4.19. Статистика для операций синхронизации (flush) была добавлена в ядре Linux 5.5. Их изучение помогает сузить поле поиска причин задержки диска.
9.6.1


#### Исторические статистики производительности 
Генератор отчетов о работе системы (system activity reporter) sar используют
для наблюдения за текущей активностью, а также генерирования хронологических отчетов. Расписание сбора статистик старых ОС определяется в файле crontab для sysstat (/etc/cron.d/sysstat и /etc/cron.weekly/sysstat), на Астре и RH8 сбор выполняется через systemd сервисы (sysstat.service, sysstat-collect.service, sysstat-summary.service). По умолчанию данные об активности cобираються каждые 10 минут, на некоторых серверах сбор выполняется ежеминутно.
Версия для Linux предлагает следующие возможности для анализа производительности процессора:
- P ALL: то же, что и mpstat -P ALL;
- u: выводит ту же информацию, что и mpstat без параметров, — только среднее общесистемное значение;
- q: включает размер очереди на выполнение как runq-sz (ту же информацию включает в вывод параметр r утилиты vmstat) и средние значения нагрузки.

Cтатистики, характеризующих потребление памяти:
- r: потребление памяти, поддерживает параметр ALL;
  - kbmemfree - Объем свободной памяти (вообще не использованной) (Кбайт)
  - kbavail - Объем доступной памяти, включая память в кэше страниц, которая с легкостью может быть освобождена в любой момент (Кбайт)
  - kbmemused - Объем использованной памяти (исключая ядро) 
  - kbcommit - Выделенный объем основной памяти: оценка объема памяти, необходимого для обслуживания текущей рабочей нагрузки
- S: статистики потребления пространства подкачки;
  - kbswpcad - Количество кэшированной памяти в килобитах. Это память, которая, как только была вытеснена в swap, подгружена обратно, но все же также находится в swap (это уменьшает операции ввода/вывода )
  - %swpcad - Процент кэшированной памяти по swop по отношению к объему использованного пространства swap.
- B: статистики подкачки страниц;
  - pgpgin/s Объем загрузки страниц из устройства подкачки 
  - pgpgout/s Объем выгрузки страниц в устройства подкачки 
  - fault/s Количество мажорных и минорных сбоев страниц вместе в секунду
  - majflt/s Количество мажорных сбоев страниц в секунду 
  - pgfree/s Количество страниц, добавляемых в список свободных страниц, в секунду
  - pgscank/s Количество страниц, отсканированных демоном подкачки страниц (kswapd) в фоновом режиме, в секунду
  - pgscand/s Количество прямых сканирований страниц в секунду
- W: статистики подкачки;
- H: статистики использования огромных страниц.
Названия многих статистик включают единицы измерения: pg — страницы, kb — килобайты, % — проценты и /s — в секунду.

Статистики, характеризующих потребление диска:
- v: статистика использования дескрипторов файлов (file-nr) и индексных дескрипторов (inode-nr), dentunusd количество неиспользуемых (свободных) записей в кэше каталогов
- b: общая статистикa ввода/вывода
- dp: статистика для каждого блочного устройства с отображением имени (похож на вывод iostat с параметром -xs)

Запуск sar -A выводит все статистики. Запуск с параметром -f позволяет просмотреть статистику архива sar, которые сохраняются в /var/log/sysstat/saXX или /var/log/sa/saXX (для RH), где XX-интересующее нас число. Также можно указать интервал выборки данных черех параметры -s (начало) -e (окончание).
Например, так:
```bash
sar -A -f /var/log/sysstat/sa23 -s 17:00 -e 17:30
```
6.6.4


ps
Команда ps выводит подробную информацию обо всех процессах, включая статистики потребления процессора и памяти (делая как бы снимок текущих процессов).
Вот пример использования параметров в стиле BSD (отсутствие дефиса перед параметрами aux):
```bash
ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
bind 1152 0.0 0.4 348916 39568 ? Ssl Mar27 20:17 /usr/sbin/named -u bind
root 1371 0.0 0.0 39004 2652 ? Ss Mar27 11:04 /usr/lib/postfix/master
root 1386 0.0 0.6 207564 50684 ? Sl Mar27 1:57 /usr/sbin/console-kit-daemon --no-daemon
rabbitmq 1469 0.0 0.0 10708 172 ? S Mar27 0:49 /usr/lib/erlang/erts-5.7.4/bin/epmd -daemon
rabbitmq 1486 0.1 0.0 150208 2884 ? Ssl Mar27 453:29 /usr/lib/erlang/erts-5.7.4/bin/beam.smp -W w -K true -A30
```
В столбце TIME отображается общее процессорное время, потраченное процессом
(в режиме пользователя и ядра) с момента его создания, в часах:минутах:секундах.
Cтолбец %CPU показывает среднюю нагрузку на CPU за все время работы процесса, суммированную по всем CPU. Для однопоточного вычислительного процесса в этом столбце будет выводиться 100%, для двухпоточного вычислительного процесса — 200%.
%MEM: доля основной памяти (физической памяти, RSS) в процентах от общего объема памяти в системе.
VSZ: размер виртуальной памяти в килобайтах, абстракция, которая предоставляеся каждому процессу отдельное большое и линейное адресное пространство.
Ядро может ограничивать общий объем виртуальной памяти. Обычно этот предел определяется размером основной памяти и емкостью физических устройств подкачки (swap). Ядро может потерпеть неудачу при попытке выделить память выше этого предела. В Linux также допускаются другие варианты поведения, в том числе отсутствие ограничений на выделение памяти. Эта стратегия называется overcommit (чрезмерное выделение памяти) за это отвечает параметр ядра vm.overcommit_memory.
RSS: размер резидентного набора в килобайтах, показывает фактический объем основной памяти, используемой процессом, но в это число входят также сегменты разделяемой памяти, например, занятые системными библиотеками, которые могут отображаться в адресные пространства других процессов. 
Если нужно прям точное значение то в Linux существует дополнительный параметр — PSS (proportional set size) пропорционального размера набора, включающий собственную память процесса (неразделяемую) плюс объем разделяемой памяти, деленный на количество потребителей. 
Получить метрику PSS можно инструментом pmap (например pmap -X <PID>)

Вывод команды ps можно отсортировать по столбцам со статистиками, характеризующими потребление памяти, чтобы быстро выявить самых активных потребителей. 
Так например настроен мониторинг TOP 5 utilization memory в oko:
```bash
ps -Ao pid,pcpu,pmem,user,s,comm --sort=-pmem | head -6
```


top
Команда top наблюдает за запущенными процессами, регулярно обновляя информацию на экране:
```bash
$ top
top - 01:38:11 up 63 days, 1:17, 2 users, load average: 1.57, 1.81, 1.77
Tasks: 256 total, 2 running, 254 sleeping, 0 stopped, 0 zombie
Cpu(s): 2.0%us, 3.6%sy, 0.0%ni, 94.2%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st
Mem: 49548744k total, 16746572k used, 32802172k free, 182900k buffers
Swap: 100663292k total, 0k used, 100663292k free, 14925240k cached
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
11721 web 20 0 623m 50m 4984 R 93 0.1 0:59.50 node
11715 web 20 0 619m 20m 4916 S 25 0.0 0:07.52 node
10 root 20 0 0 0 0 S 1 0.0 248:52.56 ksoftirqd/2
51 root 20 0 0 0 0 S 0 0.0 0:35.66 events/0
11724 admin 20 0 19412 1444 960 R 0 0.0 0:00.07 top
1 root 20 0 23772 1948 1296 S 0 0.0 0:04.35 init
```
В верхней части выводится сводная информация о системе в целом, а ниже — список процессов/задач, по умолчанию отсортированный по убыванию потребления процессорного времени. Информация на экране обновляется каждые 3 секунды (интервал можно изменить клавишей `s`).
Общесистемная сводка включает средние значения нагрузки и состояния CPU: %us, %sy, %ni, %id, %wa, %hi, %si, %st. Эти состояния эквивалентны тем, которые выводит утилита mpstat. Также сообщается общий, использованный и свободный, объем как основной памяти (Mem), так и виртуальной (Swap). Также показаны размеры кэша буферов (buffers) и кэша страниц (cached). Столбец %CPU показывает общую нагрузку на CPU за текущий интервал между обновлениями экрана, по умолчанию 3 сек (интервал можно изменить клавишей `s`). В Linux эта величина не нормализуется количеством CPU, поэтому для процесса с двумя вычислительными потоками top будет сообщать значение 200 %. В терминологии top этот режим называется «режимом Irix», в память о таком поведении утилиты в системе IRIX. Его можно переключить в «режим Solaris» (нажав клавишу `I`), в котором нагрузка на CPU делится на количество CPU. Клавишей `Shift + H` можно переключиться в режим вывода информации по потокам. Столбцы, отображающие процент использованной основной памяти (%MEM), размер виртуальной памяти (VIRT) и размер резидентного набора (RES), сообщают те же значения, что и эквивалентные столбцы в выводе ps. Клавиша `e` переключает отображение едениц потребления памяти в удобочитаемый вид, клавишей `Shift + > или <` можно выполнять сортировку по столбцам, клавишей `b` включать подсветку полей.

Клавишей `f` можно добавить/убавить столбцы с информацией (например можно вывести колонку SWAP, P, nMaj, nMin. USED):
- PR - приоритет задачи при планировании, чем меньше тем больше процессороного времени получает задача.
- P - показывает на каком процессоре выполняется задача.
- nMin (minor fault) - это отображение виртуальной страницы памяти в физическую, которое завершилось ошибкой. Если отображение можно выполнить, начиная с другой страницы в памяти, то это называется минорным сбоем. Это может происходить при отображении новой страницы из доступной памяти во время увеличения объема памяти процесса. Это также может произойти при отображении в другую существующую страницу, например, при чтении страницы из разделяемой библиотеки.
- nMaj (major fault) - Сбои страниц, требующие доступа к запоминающему устройству например, доступ к некэшированному файлу, отображаемому в память, называются мажорным сбоем.
- SWAP — область на диске для хранения выгружаемых анонимных страниц памяти.
Это может быть область на запоминающем устройстве, которую называют физическим устройством подкачки, или файл в файловой системе, который называют файлом подкачки.
- USED - RES + SWAP.

Поскольку утилита top создает моментальные снимки /proc, то может пропустить короткоживущие процессы, которые успевают запуститься и завершиться между моментами создания снимков. Вариант top для Linux с названием atop использует механизм учета процессов за интервал времени, чтобы не пропустить короткоживущие процессы и включить их в отображаемую таблицу.
6.6.6

pidstat 1
Инструмент pidstat в Linux выводит данные о потреблении CPU по процессам или потокам, в том числе с разбивкой по времени в режиме пользователя/ядра.
По умолчанию в интервальный вывод включаются только активные процессы.
```bash
pidstat 1
Linux 2.6.35-32-server (dev7) 11/12/12 _x86_64_ (16 CPU)
22:24:42 PID %usr %system %guest %CPU CPU Command
22:24:43 7814 0.00 1.98 0.00 1.98 3 tar
22:24:43 7815 97.03 2.97 0.00 100.00 11 gzip
22:24:43 PID %usr %system %guest %CPU CPU Command
22:24:44 448 0.00 1.00 0.00 1.00 0 kjournald
22:24:44 7814 0.00 2.00 0.00 2.00 3 tar
22:24:44 7815 97.00 3.00 0.00 100.00 11 gzip
22:24:44 7816 0.00 2.00 0.00 2.00 2 pidstat
```
Для вывода всех процессов, включая простаивающие, можно использовать параметр -p ALL. Параметр -t выводит статистики по потокам.
Параметр -d выводит статистику потребления дискового ввода/вывода
```bash
pidstat -d 1
Linux 5.3.0-1010-aws (ip-10-0-239-218) 02/13/20 _x86_64_ (2 CPU)
09:47:41 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
09:47:42 0 2705 32468.00 0.00 0.00 5 tar
09:47:42 0 2706 0.00 8192.00 0.00 0 gzip
09:47:56 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command
09:47:57 0 229 0.00 72.00 0.00 0 systemd-journal
09:47:57 0 380 0.00 4.00 0.00 0 auditd
09:47:57 0 2699 4.00 0.00 0.00 10 kworker/u4:1-flush-259:0
09:47:57 0 2705 15104.00 0.00 0.00 0 tar
09:47:57 0 2706 0.00 6912.00 0.00 0 gzip
```
- kB_rd/s: прочитано килобайт в секунду;
- kB_wd/s: записано килобайт в секунду;
- kB_ccwr/s: отменено для записи килобайт в секунду (например, при повторной записи или при удалении перед выталкиванием на диск);
- iodelay: время, в течение которого процесс оставался заблокированным в ожидании завершения дискового ввода/вывода (в тактах часов), включая подкачку.
Некоторые полезные опции:
-r: для вывода сбойных страниц и утилизации памяти
-p PID: для просмотра конкретного процесса
-С comm: выводиться информация для всех процессов в которые входит некоторое ключевое слово Эта строка может быть регулярным выражением. Используя опцию -l, можно просмотреть полный путь команды, а также ее аргументы.
Если запросить pidstat больше чем по одному параметру, он покажет одну информацию за другой.Однако если вы хотите увидеть всю информацию в одну строку по определенному процессу, используйте опцию -h
6.6.7

iotop - При запуске без аргументов команда обновляет экран каждую секунду и выводит список процессов, являющихся основными потребителями дискового ввода/вывода.
Для непрерывного вывода (без очистки экрана) можно использовать пакетный режим (-b), для вывода только процессов, осуществляющих ввод/вывод используем ключ -o:
```bash
# iotop -bo
Total DISK READ: 4.78 K/s | Total DISK WRITE: 15.04 M/s
TID PRIO USER DISK READ DISK WRITE SWAPIN IO COMMAND
22400 be/4 root 4.78 K/s 0.00 B/s 0.00 % 13.76 % [flush-252:0]
279 be/3 root 0.00 B/s 1657.27 K/s 0.00 % 9.25 % [jbd2/vda2-8]
22446 be/4 root 0.00 B/s 10.16 M/s 0.00 % 0.00 % beam.smp -K true ...
Total DISK READ: 0.00 B/s | Total DISK WRITE: 10.75 M/s
TID PRIO USER DISK READ DISK WRITE SWAPIN IO COMMAND
279 be/3 root 0.00 B/s 9.55 M/s 0.00 % 0.01 % [jbd2/vda2-8]
22446 be/4 root 0.00 B/s 10.37 M/s 0.00 % 0.00 % beam.smp -K true ...
646 be/4 root 0.00 B/s 272.71 B/s 0.00 % 0.00 % rsyslogd -n -c 5
```
- DISK READ: скорость чтения в килобайтах в секунду;
- DISK WRITE: скорость записи в килобайтах в секунду;
- SWAPIN: процент времени, в течение которого поток ожидал завершения ввода/вывода подкачки;
- IO: процент времени, в течение которого поток ожидал завершения ввода/вывода.


### Инструменты наблюдения за работой сети
Первыми рассматриваются инструменты ss, ip и nstat, так как входят в состав пакета iproute2, который поддерживается инженерами, разрабатывающими сетевую подсистему в ядре. Инструменты из этого пакета практически всегда поддерживают самые новые функции ядра Linux. Также здесь рассматриваются аналогичные инструменты из пакета net-tools — ifconfig и netstat, — потому
что они получили широкое распространение, хотя инженеры сетевой подсистемы в ядре Linux считают их устаревшими.

ss - сообщает статистики, характеризующие работу открытых сокетов. По умолчанию выводится обобщенная информация о сокетах. При запуске с параметрами ss может сообщить гораздо больше информации. 
Например, с параметром –p — информация о процессах, -l - показать сокеты, ожидающие подключения, с параметром –u будут отображаться сокеты UDP, с параметром –t будут отображаться сокеты TCP, с параметром –o включить информацию, относящуюся к сетевым таймерам:
```bash
# ss -pluto
Netid     State      Recv-Q     Send-Q         Local Address:Port            Peer Address:Port     Process
udp       UNCONN     0          0                    0.0.0.0:bootpc               0.0.0.0:*         users:(("dhclient",pid=493,fd=7))
udp       UNCONN     0          0                    0.0.0.0:56508                0.0.0.0:*         users:(("avahi-daemon",pid=392,fd=14))
udp       UNCONN     0          0                    0.0.0.0:mdns                 0.0.0.0:*         users:(("avahi-daemon",pid=392,fd=12))
udp       UNCONN     0          0                       [::]:56780                   [::]:*         users:(("avahi-daemon",pid=392,fd=15))
udp       UNCONN     0          0                       [::]:mdns                    [::]:*         users:(("avahi-daemon",pid=392,fd=13))
tcp       LISTEN     0          4096               127.0.0.1:44819                0.0.0.0:*         users:(("containerd",pid=599,fd=10))
tcp       LISTEN     0          128                  0.0.0.0:ssh                  0.0.0.0:*         users:(("sshd",pid=630,fd=3))
tcp       LISTEN     0          128                127.0.0.1:ipp                  0.0.0.0:*         users:(("cupsd",pid=16041,fd=7))
tcp       LISTEN     0          128                     [::]:ssh                     [::]:*         users:(("sshd",pid=630,fd=4))
tcp       LISTEN     0          128                    [::1]:ipp                     [::]:*         users:(("cupsd",pid=16041,fd=6))
```
Без параметра -l вывод отражает текущие соединения.
```bash
# ss -puto
Netid           State           Recv-Q           Send-Q                     Local Address:Port                     Peer Address:Port           Process
tcp             ESTAB           0                0                           192.168.1.12:ssh                       192.168.1.5:64294           users:(("sshd",pid=16297,fd=4),("sshd",pid=16277,fd=4)) timer:(keepalive,89min,0)
tcp             ESTAB           0                48                          192.168.1.12:ssh                       192.168.1.5:64521           users:(("sshd",pid=16809,fd=4),("sshd",pid=16807,fd=4)) timer:(on,234ms,0)
```
Поскольку в выводе перечислены все установленные соединения с информацией об IP-адресах, его можно использовать для определения характеристик текущей рабочей нагрузки и получения ответов на такие вопросы, как количество открытых клиентами соединений, количество одновременно действующих соединений и т. д.
Аналогичную информацию по сокетам можно получить через инструмент netstat, Однако ss получает эти сведения из интерфейса netlink, который, в свою очередь, использует сокеты семейства AF_NETLINK для получения информации из ядра, а netstat получает эту же информацию из файлов в /proc/net.
ss c параметром –i будет дополнительно выводить внутреннюю информацию TCP:
```bash
# ss -putoi
State Recv-Q Send-Q Local Address:Port Peer Address:Port
ESTAB 0 0 100.85.142.69:65264 100.82.166.11:6001
users:(("java",pid=4195,fd=10865)) uid:33 ino:2009918 sk:78 <->
skmem:(r0,rb12582912,t0,tb12582912,f266240,w0,o0,bl0,d0) ts sack bbr ws
cale:9,9 rto:204 rtt:0.159/0.009 ato:40 mss:1448 pmtu:1500 rcvmss:1448 advmss:14
48 cwnd:152 bytes_acked:347681 bytes_received:1798733 segs_out:582 segs_in:1397
data_segs_out:294 data_segs_in:1318 bbr:(bw:328.6Mbps,mrtt:0.149,pacing_gain:2.8
8672,cwnd_gain:2.88672) send 11074.0Mbps lastsnd:1696 lastrcv:1660 lastack:1660
pacing_rate 2422.4Mbps delivery_rate 328.6Mbps app_limited busy:16ms rcv_rtt:39.
822 rcv_space:84867 rcv_ssthresh:3609062 minrtt:0.139
```
- "java",pid = 4195: имя процесса «java» и его идентификатор PID 4195;
- fd = 10865: дескриптор файла 10865 (для процесса с PID 4195);
- rto:204: тайм-аут повторной передачи TCP, в данном случае 204 мс;
- rtt:0,159/0,009: среднее время приема-передачи составляет 0,159 мс со средним отклонением 0,009 мс;
- mss:1448: максимальный размер сегмента 1448 байт;
- cwnd:152: размер окна перегрузки: 152 × MSS;
- bytes_acked:347681: успешно передано 340 Кбайт;
- bytes_received:1798733: получено 1,72 Мбайт;
- bbr:...: статистика алгоритма BBR управления перегрузкой;
- minrtt:0.139: минимальное время приема/передачи в миллисекундах. Срав-
ните со средним значением и средним отклонением (см. выше), чтобы получить
представление о переменчивости пропускной способности сети и ее перегрузке.
Кроме того команда netstat может выводить дополнительную информацию
- s: статистики сетевого стека;
- i: статистики сетевого интерфейса;
- r: таблица маршрутизации
Вот пример получения статистик сетевого интерфейса с помощью netstat:
```bash
$ netstat -i
Kernel Interface table
Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0 1500 933760207 0 0 0 1090211545 0 0 0 BMRU
eth3 1500 718900017 0 0 0 587534567 0 0 0 BMRU
lo 16436 21126497 0 0 0 21126497 0 0 0 LRU
ppp5 1496 4225 0 0 0 3736 0 0 0 MOPRU
ppp6 1496 1183 0 0 0 1143 0 0 0 MOPRU
tun0 1500 695581 0 0 0 692378 0 0 0 MOPRU
tun1 1462 0 0 0 0 4 0 0 0 PRU
```
В колонках выводятся: имя сетевого интерфейса (Iface), размер MTU и последо-
вательность статистик для приема (RX-) и передачи (TX-):
- OK: успешно принятых/отправленных пакетов;
- ERR: количество ошибок приема/отправки пакетов;
- DRP: количество отброшенных пакетов;
- OVR: переполнений.

ip — это инструмент для управления маршрутизацией, сетевыми устройствами,
интерфейсами и туннелями. Для целей наблюдения с его помощью можно выводить
информацию об интерфейсах, адресах, маршрутах и т. д. Ниже приведен вывод
расширенных статистик (-s) об интерфейсах (link):
```bash
ip -s link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT
group default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
RX: bytes packets errors dropped overrun mcast
26550075 273178 0 0 0 0
TX: bytes packets errors dropped carrier collsns
26550075 273178 0 0 0 0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT
group default qlen 1000
link/ether 12:c0:0a:b0:21:b8 brd ff:ff:ff:ff:ff:ff
RX: bytes packets errors dropped overrun mcast 512473039143 568704184 0 0 0 0
TX: bytes packets errors dropped carrier collsns 573510263433 668110321 0 0 0 0
```
Информация о конфигурации интерфейсов пригодится во время статической настройки производительности для проверки правильности конфигурации. В вывод также включены метрики ошибок: для приема (RX): количество ошибок приема, отброшенных пакетов и переполнений; для передачи (TX): количество ошибок передачи, отброшенных пакетов, ошибок несущей и коллизий. Такие ошибки могут быть причиной проблем с производительностью и, в зависимости от ошибки, вызываться неисправным сетевым оборудованием. Это глобальные счетчики, суммирующие все ошибки с момента инициализации интерфейса (когда он был «поднят»).
Передав параметр -s дважды (-s -s), можно получить более подробную информацию об ошибках. При вызове с параметром route этот инструмент выводит таблицу маршрутизации.

Команда ifconfig — это традиционный инструмент для администрирования сетевых интерфейсов, который также отображает информацию о конфигурации. В Linux команда ifconfig считается устаревшей, и на замену ей пришла команда ip.

sar - предлагает следующие возможности для анализа производительности сети:
-n DEV: статистики сетевого интерфейса DEV (количество пакетов и пропускная способность);
-n EDEV: ошибки сетевого интерфейса DEV;
-n IP: статистики по IP-дейтаграммам;
-n EIP: ошибки IP;
-n TCP: статистики TCP (астота приема соединений, частота повторных передач);
  - active/s Новых активных соединений TCP (connect)
  - passive/s Новых пассивных соединений TCP (accept)
-n ETCP: ошибки TCP;
-n SOCK: информация о потреблении сокетов.
Полный список статистик можно найти на странице справочного руководства man. Многие из названий статистик в sar легко читаются, потому что включают направление и измеряемые единицы: rx — «принято» (received), tx - «отправлено» (transmitted) i — «входящий» (input), seg — «сегменты» и т. д.
Таким образом можно отфильтровать интересующий интерфейс:
```bash
sar -n DEV 1 | awk 'NR == 3 || $2 == "eth0"'
```
10.6.6

apt install ethtool
ethtool - можно использовать для проверки параметров настройки сетевых интерфейсов, если добавить параметры -i и -k, а также статистик драйверов, если добавить параметр -S. 
Например вывести информацию об ошибках:
```bash
ethtool -S eno1 | grep err
```


### Профилирование процессора в масштабе всей системы
perf — это официальный профилировщик в Linux, многофункциональный инструмент с множеством возможностей.
perf можно использовать для профилирования процессора, чтобы выявить пути в коде как в пространстве ядра, так и в пространстве пользователя, на выполнение которых тратится процессорное время. Это делают с помощью команды record, которая сохраняет образцы стека в файл perf.data. По окончании профилирования содержимое этого файла можно исследовать с помощью команды report.
Установка:
```bash
apt install linux-tools-$(uname -r)
# или
yum install perf
```
Команда профилирования в следующем примере выбирает все (-g) трассировки стека вызовов со всех (-a1) процессоров с частотой 99 Гц (-F 99) в течение 10 с (sleep 10):
```bash
perf record -F 99 -a -g -- sleep 10
perf report
```
Флейм-графики процессорного времени можно сгенерировать из профиля perf.data командой flamegraph
```bash
perf script --header > out.stacks
git clone https://github.com/brendangregg/FlameGraph; cd FlameGraph
./stackcollapse-perf.pl < ../out.stacks | ./flamegraph.pl --hash > out.svg
mv ./out.svg /tmp/out.svg
```
Файл out.svg — это флейм-график процессорного времени, который можно открыть в браузере. 

Команда sched фиксирует и выводит статистики планировщика. Например:
```bash
perf sched record -- sleep 10
perf sched latency
-------------------------------------------------------------------------------------
Task | Runtime ms | Switches | Average delay ms | Maximum delay ms |
-------------------------------------------------------------------------------------
jbd2/nvme0n1p1-:175 | 0.209 ms | 3 | avg: 0.549 ms | max: 1.630 ms |
kauditd:22 | 0.180 ms | 6 | avg: 0.463 ms | max: 2.300 ms |
oltp_read_only.:(4) | 3969.929 ms | 184629 | avg: 0.007 ms | max: 5.484 ms |
mysqld:(27) | 8759.265 ms | 96025 | avg: 0.007 ms | max: 4.133 ms |
bash:21391 | 0.275 ms | 1 | avg: 0.007 ms | max: 0.007 ms |
-------------------------------------------------------------------------------------
TOTAL: | 12916.132 ms | 281395 |
-------------------------------------------------
```
Этот отчет о задержке обобщает среднюю и максимальную задержку планировщика (также известную как задержка в очереди на выполнение) для каждого процесса.

Подкоманда stat подсчитывает события и выводит сводную информацию без записи событий в файл perf.data.
perf stat -a -- sleep 30
Есть множество аппаратных событий, которые можно подсчитывать. Их можно перечислить командой `perf list`:
```bash
perf stat -e instructions,cycles,L1-dcache-load-misses,LLC-load-misses,dTLB-load-misses -a -- sleep 10
```
Помимо инструкций и тактов, в этом примере измерялись:
- L1-dcache-load-misses: промахи чтения из кэша данных уровня 1. Это значение дает представление о нагрузке на память, создаваемой приложением, с учетом того, что некоторые операции чтения были удовлетворены из кэша уровня 1. Это значение сопоставляют с другими счетчиками событий кэша L1, чтобы определить коэффициент попаданий в кэш.
- LLC-load-misses: промахи чтения из кэша последнего уровня. После неудачной попытки получить данные из кэша последнего уровня следует обращение к основной памяти, то есть это значение — мера нагрузки на основную память. Разница между этим счетчиком и L1-dcache-load-misses дает представление об эффективности кэшей процессора за пределами уровня 1, но для полноты картины желательно определить значения других счетчиков.
- dTLB-load-misses: промахи в буфере данных ассоциативной трансляции. Этот счетчик показывает эффективность блока управления памятью (MMU) в части кэширования отображений страниц для рабочей нагрузки и может измерять величину рабочей нагрузки на память (рабочий набор).


Установка инструментов BCC из стандартных репозиториев:
```bash
apt install bpfcc-tools linux-headers-$(uname -r)
# или
yum install bcc-tools
```
profile — это инструмент для BCC, который выбирает трассировки стека с за-
данным интервалом и сообщает частоту каждой из них.
profile-bpfcc

